package chapter13._1collection.child.map;

public class TreeMaps {

    /**
     * Tree 구조의 데이터 검색 방법 및 시간 복잡도 계산
     *
     * Ex) 아래와 같은 Tree 구조가 있다면
     *      4
     *   2      7
     * 1   3  6   8
     * 순회해야 하는 횟수 = n이라고 정의하면
     * Tree는 아래로 내려가면서 값을 찾을 수 있으므로
     * 예를 들어 8을 찾아야 한다고 하면 아래와 같은 알고리즘으로 검색해나간다.
     * [4(1회 순회) -> 찾으려는 8보다 작음 -> 부모보다 큰 자식은 오른쪽 가지에 위치함 -> 7(2회 순회) -> 찾으려는 8보다 작음
     * -> 부모보다 큰 자식은 오른쪽 가지에 위치함 -> 8 (3회 순회, 검색 완료)]
     * 즉, 최악의 경우에 n=3이다.
     * 하지만 이런 Tree 구조가 아닌 선형 구조로 이루어진 자료 구조라면,
     * [1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8(8회 순회, 검색 완료)]
     * 최악의 경우 n=8이다.
     * 최악의 경우를 가정하는 시간 복잡도 계산에서 보면 선형 자료 구조는 데이터 검색에서 O(n), 자료 구조의 길이만큼 순회를 해야한다.
     * 하지만 Tree의 경우에는 O(logn) 으로 트리의 높이 만큼만 순회하면 원하는 값을 찾을 수 있다.
     * 동일하게 범위 검색도 Tree 가 효율적으로 검색 결과를 반환해준다.
     * O(logn)으로 위를 계산해보면 밑이 2인 log8의 계산을 하게 되면 결과값은 3이 나오게 된다.
     *
     * 간단하게 위의 정해진 트리 구조로 계산을 했지만 데이터의 표본이 무한정 커진다고 해도 log 계산을 하게 되면
     * 선형 자료 구조보다 기하급수적으로 순회 횟수가 줄어들게 된다.
     * */

    /**
     * 왜 Tree 컬렉션보다 Hash 컬렉션을 자주 쓸까?
     * 1. Tree는 항상 정렬(트리 밸런싱)이 되어있어야 함(데이터 추가/삭제의 오버헤드)
     * 2. 일반적인 비즈니스에서는 컴퓨터가 1대1 해싱하지 못할 규모의 데이터를 처리하는 경우가 극히 드물다
     * 3. 단일 검색이나 데이터 추가/삭제 등에 사실상 특화된 자료 구조가 HashTable 이며 이 이후에 나온 것이 바로 HashMap이다.
     *
     * HashMap대신에 TreeMap을 쓰는 것이 좋은 경우
     * 1. 범위 검색(위의 Tree 데이터 검색 방법 참고)
     * 2. 정렬(Tree는 기본적으로 정렬되어 있어야 하므로 추가적인 정렬 작업이 필요하지 않은 까닭)
     *
     * */

    /**
     * TreeMap 의 메서드들은 TreeSet과 매우 유사하며 Set은 키를 관리하지 않기 때문에 자신의 값을 기준으로 메서드가 동작하는데
     * TreeMap 은 키-값 쌍으로 데이터가 움직이기 때문에 기본적으로 정렬 및 범위 검색 등을 키를 기준으로 진행하게 된다.
     * 예를 들어서 headSet, tailSet 과 유사하게 TreeMap 도 headMap, tailMap 과 같은 메서드를 가지고 있는데
     * headSet은 어떤 값을 기준으로 작은 값들을 반환하는데 headMap은 어떤 키를 기준으로 작은 키-값을 반환하게 되어
     * 메서드 구조 자체는 TreeSet과 유사하므로 메서드의 동작은 TreeSet을 참조하자.
     * */
}
